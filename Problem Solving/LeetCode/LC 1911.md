#dp 
```cpp
class Solution {
public:
    int n;
    long long t[1000001][2];  // Memoization table: t[index][iseven]. iseven: 1 = add, 0 = subtract.
    
    // The recursive function.
    // 'idx' is the current index in the array.
    // 'iseven' is a boolean flag that indicates if the current element (if taken) should be added (true) or subtracted (false).
    long long solve(int idx, vector<int>& nums, bool iseven) {
        // Base case: if we've processed all elements, there's nothing to add.
        if(idx >= n) {
            return 0;
        }
        
        // If we have computed this state before, return its value.
        if(t[idx][iseven] != -1)
            return t[idx][iseven];
        
        // Option 1: Skip the current element.
        long long skip = solve(idx+1, nums, iseven);
        
        // Option 2: Take the current element.
        // Set 'val' to nums[idx]. If it's not an "even" position (i.e. iseven is false), we subtract it.
        long long val = nums[idx];
        if(iseven == false) {
            val = -val;
        }
        
        // After taking the element, flip the sign for the next element (!iseven).
        long long take = solve(idx+1, nums, !iseven) + val;
        
        // Store and return the maximum result between skipping and taking the current element.
        return t[idx][iseven] = max(skip, take);
    }
    
    long long maxAlternatingSum(vector<int>& nums) {
        n = nums.size();
        // Initialize the memoization table with -1 to indicate uncomputed states.
        memset(t, -1, sizeof(t));
        // Start recursion at index 0 with 'iseven' true (first element will be added).
        return solve(0, nums, true);
    }
};

```

